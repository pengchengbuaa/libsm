//
// Created by Niujx on 2018-03-12.
//
// Sample 1
// Input:"abc"
// Output:66c7f0f4 62eeedd9 d1f2d46b dc10e4e2 4167c487 5cf2f7a2 297da02b 8f4ba8e0

// Sample 2
// Input:"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd"
// Outpuf:debe9ff9 2275b8a1 38604889 c18e5a4d 6fdb70e5 387e5765 293dcba3 9c0c5732

static SM3_PADDING: [u8; 64] = [
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

pub struct Sm3Hash {
    digest: [u32; 8],
    length: u64,
    unhandle_msg: Vec<u8>,
}

impl Sm3Hash {
    pub fn new(data: &String) -> Sm3Hash {
        let mut hash = Sm3Hash {
            digest: [0x7380166f, 0x4914b2b9, 0x172442d7, 0xda8a0600, 0xa96f30bc, 0x163138aa, 0xe38dee4d, 0xb0fb0e4e],
            length: 0,
            unhandle_msg : Vec::new(),
        };
        for i in data.bytes(){
            hash.unhandle_msg.push(i);
        }
        hash
    }

    pub fn pad(&self){
        let mut msg=&self.unhandle_msg;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn lets_hash() {
        let s = String::from("abc");
        let sm3 = Sm3Hash::new(&s);
        println!("{:?}",sm3.unhandle_msg);


        //hash:[u8,32];

        let standrad_hash: [u8;32]=[
            0x66,0xc7,0xf0,0xf4,0x62,0xee,0xed,0xd9,
            0xd1,0xf2,0xd4,0x6b,0xdc,0x10,0xe4,0xe2,
            0x41,0x67,0xc4,0x87,0x5c,0xf2,0xf7,0xa2,
            0x29,0x7d,0xa0,0x2b,0x8f,0x4b,0xa8,0xe0
        ];

        for i in 0..32{
            assert_eq!(standrad_hash[i], standrad_hash[i]);
        }
    }
}